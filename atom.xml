<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Xujiongbo]]></title>
  
  <link href="/blog/atom.xml" rel="self"/>
  <link href="https://xujiongbo.github.io/blog/"/>
  <updated>2017-01-20T03:15:38.000Z</updated>
  <id>https://xujiongbo.github.io/blog/</id>
  
  <author>
    <name><![CDATA[Xujiongbo]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[正则表达式进阶]]></title>
    <link href="https://xujiongbo.github.io/blog/post/advanced-regular-expression/"/>
    <id>https://xujiongbo.github.io/blog/post/advanced-regular-expression/</id>
    <published>2017-01-20T13:13:29.000Z</published>
    <updated>2017-01-20T03:15:38.000Z</updated>
    <content type="html"><![CDATA[<a id="more"></a>]]></content>
    <summary type="html">
    <![CDATA[<a id="more"></a>]]>
    </summary>
    
  </entry>
  
  <entry>
    <title><![CDATA[MediaQueryList - JS中的媒体查询]]></title>
    <link href="https://xujiongbo.github.io/blog/post/media-query-list/"/>
    <id>https://xujiongbo.github.io/blog/post/media-query-list/</id>
    <published>2016-12-08T15:53:11.000Z</published>
    <updated>2016-12-11T13:30:22.000Z</updated>
    <content type="html"><![CDATA[<h4 id="媒体查询(Media_Queries)">媒体查询(Media Queries)</h4><p>我们都知道<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries" target="_blank" rel="external">媒体查询</a>在响应式设计中扮演着一个重要的角色，它可以让我们在不同特性的设备上应用不同的CSS样式。一种常见的应用如下：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在width不大于640的设备上，aside将被隐藏 */</span></span><br><span class="line"><span class="at_rule">@<span class="keyword">media</span> (max-width: <span class="number">640px</span>) </span>&#123;</span><br><span class="line">  <span class="tag">aside</span> <span class="rules">&#123;</span><br><span class="line">    <span class="rule"><span class="attribute">display</span>:<span class="value"> none</span></span>;</span><br><span class="line">  &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实在JavaScript中通过MediaQueryList接口，也可以进行媒体查询。</p>
<h4 id="MediaQueryList是什么?">MediaQueryList是什么?</h4><p><a href="https://www.w3.org/TR/cssom-view-1/#the-mediaquerylist-interface" target="_blank" rel="external">MediaQueryList</a>(下面简称MQL)是<a href="https://www.w3.org/TR/cssom-view/" target="_blank" rel="external">CSSOM View Module</a>中定义的一个接口，一个MQL对象，本质上对应一条媒体查询，通过获取它的matches属性得到查询结果。<br>MQL对象通过调用window.matchMedia方法获得，matchMedia接受一个媒体查询字符串作为参数，并返回对应的MQL对象。一个简单的例子如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mql = <span class="built_in">window</span>.matchMedia(<span class="string">'(max-width: 640px)'</span>)</span><br><span class="line"><span class="keyword">if</span> (mql.matches) &#123;</span><br><span class="line">  <span class="comment">// width &lt;= 640px</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// width &gt; 640px</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>mql对象还提供了change事件接口，它拥有addListener(handler)和removeListener(handler)两个方法，用于监听和移除事件，这两个方法本质上是addEventListener(‘change’, handler)和addEventListener(‘change’, handler，的简写。handler是一个回调函数，传回一个MediaQueryListEvent作为参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mql = <span class="built_in">window</span>.matchMedia(<span class="string">'(max-width: 640px)'</span>)</span><br><span class="line">mql.addListener(handlMediaChange) <span class="comment">// mql.onchange = handleMediaChange</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleMediaChange</span> (<span class="params">mqle</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(mqle.matches) <span class="comment">// 更新后的boolean值</span></span><br><span class="line">  <span class="built_in">console</span>.log(mqle.media) <span class="comment">// 对应的查询字符串</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="这能做什么?">这能做什么?</h4><ol>
<li>更灵活的响应式设计<br>CSS中的媒体查询可以对相同的内容在不同的场景下作用不同的样式，而JS中的媒体查询可以让我们根据设备特性的变化直接修改内容，这是MQL最大的作用。</li>
</ol>
<ol>
<li><p>在一定程度上代替UA检测</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.matchMedia(<span class="string">'handheld'</span>)</span><br><span class="line"><span class="built_in">window</span>.matchMedia(<span class="string">'tv'</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>更简便的检测方案</p>
</li>
</ol>
<h4 id="需要注意啥?">需要注意啥?</h4><ol>
<li><p>MQL对象的matches是动态的<br>同HTMLElement上的classList, childNodes一样(不同的是classList, childNodes都是引用类型，而matches是基本类型)，第一次通过matchMedia方法获取得到mql之后，后面媒体特性发生改变，mql.matches拿到的就是最新的值，不需要再调用一次matchMedia。</p>
</li>
<li><p>兼容性<br>MQL比CSS中的媒体查询出来的晚一些，所以并不代表支持CSS媒体查询的浏览器就一定支持MQL(当然支持MQL的浏览器支持CSS Media Query是没问题的)，它的兼容性如下：</p>
</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="媒体查询(Media_Queries)">媒体查询(Media Queries)</h4><p>我们都知道<a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries" ]]>
    </summary>
    
      <category term="JavaScript" scheme="https://xujiongbo.github.io/blog/tags/JavaScript/"/>
    
      <category term="JavaScript" scheme="https://xujiongbo.github.io/blog/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript的常用API中一些可能忽略的点]]></title>
    <link href="https://xujiongbo.github.io/blog/post/javascript-apis/"/>
    <id>https://xujiongbo.github.io/blog/post/javascript-apis/</id>
    <published>2016-10-11T13:23:02.000Z</published>
    <updated>2016-12-19T15:11:12.000Z</updated>
    <content type="html"><![CDATA[<p>ECMAScript定义了一些很有用的API，像String.prototype.split、Array.prototype.sort等字符串或数组的原型方法，其中有一些API非常灵活，我们平时可能只用到了部分常用的调用方式，而忽略了它们的其他用法，在这里做个小总结。<br><a id="more"></a></p>
<h4 id="字符串String">字符串String</h4><h5 id="split的第二个参数">split的第二个参数</h5><p>String.prototype.split的第一个参数表示分隔符，可以是字符串或正则表达式；的第二个参数n是数字类型的，表示字符串被分割成长度最大为n的数组，当n小于0时会被忽略<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> text = <span class="string">"one,two,three,four,five"</span></span><br><span class="line">text.split(<span class="string">","</span>) <span class="comment">// ["one", "two", "three", "four", "five"]</span></span><br><span class="line">text.split(<span class="string">","</span>, <span class="number">2</span>) <span class="comment">// ["one", "two"]</span></span><br></pre></td></tr></table></figure></p>
<h5 id="slice，substr与substring">slice，substr与substring</h5><p>这三个方法的功能都是字符串截取（当然都不影响原字符串），并且都可以接受一或两个参数，第一个参数表示要截取的子字符串的开始位置，slice和substring的第二个参数表示的是子字符串最后一个字符后面的位置，而substr的第二个参数则表示子字符串的最大长度。当参数都为正数时，当slice的第二个参数不大于第一个参数时，会返回””，而substring的参数仍然有效。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"0123456789"</span></span><br><span class="line">str.slice(<span class="number">3</span>)        <span class="comment">// "3456789"</span></span><br><span class="line">str.substring(<span class="number">3</span>)    <span class="comment">// "3456789"</span></span><br><span class="line">str.substr(<span class="number">3</span>)       <span class="comment">// "3456789"</span></span><br><span class="line">str.slice(<span class="number">3</span>, <span class="number">6</span>)     <span class="comment">// "345"</span></span><br><span class="line">str.substring(<span class="number">3</span>, <span class="number">6</span>) <span class="comment">// "345"</span></span><br><span class="line">str.substr(<span class="number">3</span>, <span class="number">6</span>)    <span class="comment">// "345678"</span></span><br><span class="line"></span><br><span class="line">str.slice(<span class="number">5</span>, <span class="number">3</span>)     <span class="comment">// ""</span></span><br><span class="line">str.substring(<span class="number">5</span>, <span class="number">3</span>) <span class="comment">// "34"</span></span><br></pre></td></tr></table></figure></p>
<p>当传入的参数为负值是3个方法的表现就各不相同了。slice会把传入的负数与字符串的长度相加，substring会把所有的负值参数当作0，substr则会把第一个负值参数加上字符串长度，第二个负值参数转换为0。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"0123456789"</span></span><br><span class="line">str.slice(-<span class="number">3</span>)       <span class="comment">// "789"</span></span><br><span class="line">str.substring(-<span class="number">3</span>)   <span class="comment">// "0123456789"</span></span><br><span class="line">str.substr(-<span class="number">3</span>)      <span class="comment">// "789"</span></span><br><span class="line">str.slice(-<span class="number">3</span>, -<span class="number">6</span>)   <span class="comment">// ""</span></span><br><span class="line">str.slice(<span class="number">3</span>, -<span class="number">6</span>)    <span class="comment">// "3"</span></span><br><span class="line">str.substring(<span class="number">3</span>, -<span class="number">6</span>)<span class="comment">// "012"</span></span><br><span class="line">str.substr(<span class="number">3</span>, -<span class="number">6</span>)   <span class="comment">// ""</span></span><br></pre></td></tr></table></figure></p>
<h5 id="indexOf和lastIndexOf">indexOf和lastIndexOf</h5><p>indexOf和lastIndexOf都可以接收一或两个参数，要注意的是，这两个方法都是只要第一次找到子字符串就返回子串的位置，不同的是indexOf是从头开始往后查找，而lastIndexOf是从尾开始往前查找。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"123454321"</span></span><br><span class="line">str.indexOf(<span class="string">"3"</span>)        <span class="comment">// 2</span></span><br><span class="line">str.lastIndexOf(<span class="string">"3"</span>)    <span class="comment">// 6</span></span><br></pre></td></tr></table></figure></p>
<p>这两个方法都可以接受第二个参数，表示从字符串的哪个位置开始搜索。indexOf从指定的位置开始向后搜索，lastIndexOf则是从指定的位置开始向前搜索。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str = <span class="string">"123454321"</span></span><br><span class="line">str.indexOf(<span class="string">"3"</span>, <span class="number">5</span>)     <span class="comment">// 6</span></span><br><span class="line">str.lastIndexOf(<span class="string">"3"</span>, <span class="number">5</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<h5 id="replace">replace</h5><p>若String.prototype.replace的第一个参数不是带有g(global)修饰的正则表达式，则默认只会替换第一个子字符串；它的第二个参数可以是一个函数，这个函数接受的第一个参数是模式的匹配项，最后两个参数是模式的匹配项在字符串中的位置和原始字符串，在正则表达式中定义了n个捕获组的情况下，第一个参数和最后两个参数之间还会有n个参数，表示第n个捕获组的匹配项。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlEscape</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> text.replace(<span class="regexp">/[&lt;&gt;"&amp;]/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match, position, originalText</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (match) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'&lt;'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&amp;lt;'</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'&gt;'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&amp;gt;'</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'&amp;'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&amp;amp;'</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'"'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&amp;quot;'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>ECMAScript定义了一些很有用的API，像String.prototype.split、Array.prototype.sort等字符串或数组的原型方法，其中有一些API非常灵活，我们平时可能只用到了部分常用的调用方式，而忽略了它们的其他用法，在这里做个小总结。<br>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="https://xujiongbo.github.io/blog/tags/JavaScript/"/>
    
      <category term="JavaScript" scheme="https://xujiongbo.github.io/blog/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[async/await&异步编程解决方案讨论]]></title>
    <link href="https://xujiongbo.github.io/blog/post/async-await/"/>
    <id>https://xujiongbo.github.io/blog/post/async-await/</id>
    <published>2016-06-30T04:48:54.000Z</published>
    <updated>2016-11-26T13:41:45.000Z</updated>
    <content type="html"><![CDATA[<p>JavaScript是一种事件驱动的脚本语言，这就决定了异步流程控制在JavaScript中不可回避的，而async/await是ECMAScript中最新的异步解决方案，在了解async/await之前，我们先回顾一下JavaScript中异步编程的发展。<br><a id="more"></a></p>
<h5 id="1-回调Callback">1.回调Callback</h5><p>回调是我们用的最多的一种异步编程方式，以错误优先的回调机制在Node.js的API里面更是体现的淋漓尽致。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</span><br><span class="line">fs.readFile(<span class="string">'./package.json'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>但是callback在有多层嵌套的情况下会形成“回调地狱”（<a href="http://callbackhell.com/" target="_blank" rel="external">Callback Hell</a>），就像下面这样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">      setTimeout(() =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="number">5</span>)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<p>“回调地狱”使得程序难以阅读和维护，试想一下，我们现在想在上面的代码中间再加上第3层回调，改起来会有多么蛋疼。</p>
<h5 id="2-Promise">2.Promise</h5><h5 id="3-生成器Generator">3.生成器Generator</h5><h5 id="4-async/await">4.async/await</h5>]]></content>
    <summary type="html">
    <![CDATA[<p>JavaScript是一种事件驱动的脚本语言，这就决定了异步流程控制在JavaScript中不可回避的，而async/await是ECMAScript中最新的异步解决方案，在了解async/await之前，我们先回顾一下JavaScript中异步编程的发展。<br>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="https://xujiongbo.github.io/blog/tags/JavaScript/"/>
    
      <category term="JavaScript" scheme="https://xujiongbo.github.io/blog/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript小贴士]]></title>
    <link href="https://xujiongbo.github.io/blog/post/javascript-tips/"/>
    <id>https://xujiongbo.github.io/blog/post/javascript-tips/</id>
    <published>2016-01-21T08:17:27.000Z</published>
    <updated>2017-02-03T04:21:01.000Z</updated>
    <content type="html"><![CDATA[<p>JavaScript中有很多值得学习和记住的小技巧和经典的代码片段，在这里做个小总结。<br><a id="more"></a></p>
<h4 id="1-_链式方法">1. 链式方法</h4><p>jQuery中 $dom.html().css().addClass() 这类的就叫链式方法，在对象方法中返回对象本身(this)就可以实现。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Chain</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.val = val</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.val)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.setVal = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val = val</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> chain = <span class="keyword">new</span> Chain(<span class="string">'foo'</span>)</span><br><span class="line">chain.print().setVal(<span class="string">'bar'</span>).print()</span><br><span class="line"><span class="comment">//foo</span></span><br><span class="line"><span class="comment">//bar</span></span><br></pre></td></tr></table></figure></p>
<h4 id="2-_注意字符串连接">2. 注意字符串连接</h4><p>JavaScript中经常会有一些意想不到的类型转换，’+’是其中最常见的一种运算，它既可以做数字的加法，也可以做字符串连接，不注意使用可能会出现不想看到的结果。看下面的例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c1 = <span class="number">12</span>, c2 = <span class="number">34</span>, c3 = <span class="string">'56'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = c1 + c2 + c3 <span class="comment">//'4656'</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="string">''</span>.concat(c1, c2, c3) <span class="comment">//'123456'</span></span><br><span class="line"><span class="comment">/*当然也可以这样，总是在前面加个''*/</span></span><br><span class="line"><span class="keyword">let</span> result3 = <span class="string">''</span> + c1 + c2 + c3 <span class="comment">//'123456'</span></span><br></pre></td></tr></table></figure></p>
<p>结果1中先做了加法，而非我们期望的字符串连接，使用后两种方法更安全一些。<br>如果是ES6，使用template string显然更方便。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c1 = <span class="number">12</span>, c2 = <span class="number">34</span>, c3 = <span class="string">'56'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="string">`<span class="subst">$&#123;c1&#125;</span><span class="subst">$&#123;c2&#125;</span><span class="subst">$&#123;c3&#125;</span>`</span> <span class="comment">//'123456'</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3-_检查某个数是否为-1">3. 检查某个数是否为-1</h4><p>要知道if(n)只有当n(数字类型)为0时才会判定为false，而对于~n只有当n为-1时会得到0，这在使用Array.prototype.indexOf()判断某一项是否在数组中时可以起到简化代码的作用，如下<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">if</span> (a.indexOf(<span class="number">4</span>) !== -<span class="number">1</span>) &#123; <span class="comment">// 或者a.indexOf(4) &gt; -1</span></span><br><span class="line">  <span class="comment">// 数组a中含有4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用~我们可以像下面这样，代码会更简洁，只是可读性会稍稍降低<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">if</span> (~a.indexOf(<span class="number">4</span>)) &#123;</span><br><span class="line">  <span class="comment">// 数组a中含有4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="4-_双波浪运算(~~)">4. 双波浪运算(~~)</h4><p>‘~~’表示执行两次’~’(按位非)运算，对于正数，它相当于Math.floor()，对于负数则相当于Math.ceil()，只是性能更高，写起来也更快，不过要注意它只能用于32位及以内的数值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~<span class="number">12</span>       <span class="comment">//-13</span></span><br><span class="line">~~<span class="number">12.34</span>     <span class="comment">//12</span></span><br><span class="line">~~<span class="number">12.89</span>     <span class="comment">//12</span></span><br><span class="line">~~-<span class="number">12.88</span>    <span class="comment">//-12</span></span><br></pre></td></tr></table></figure></p>
<h4 id="5-_使用!!总是返回Boolean类型">5. 使用!!总是返回Boolean类型</h4><p>‘!!’表示执行两次非运算，经过类型转换之后总是会返回布尔值，这在有些场景下会很有用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isLogin</span> (<span class="params">req</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!req.session.user</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="6-_Debouncing_VS_Throttling">6. Debouncing VS Throttling</h4><p>Debouncing 和 Throttling 都是防止某个函数执行过于频繁，以提高性能。不同的是，Debouncing 表示把某一段时间内重复触发的事件归结到一次回调中执行，比如谷歌或百度的动态搜索框的文本输入事件，可以设置在键盘输入停止500ms才发起ajax请求；而 Throttling 表示的是在某一时间段内，限制某一函数只执行一次，比如一个动态加载的列表，它会在滚动到底部时加载新的列表项，然而用户的滚动事件的触发太频繁，我们可以限制它每500ms最多执行一次加载操作。更详细的说明可以参考这篇<a href="https://css-tricks.com/debouncing-throttling-explained-examples/" target="_blank" rel="external">文章</a>。<br><a href="http://underscorejs.org/#throttle" target="_blank" rel="external">underscore</a>和<a href="https://lodash.com/docs/#debounce" target="_blank" rel="external">lodash</a>都有对这两个高阶函数的实现和拓展，不考虑拓展的基本实现如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> debounce = <span class="function"><span class="keyword">function</span> (<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>,</span><br><span class="line">      self = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">      fn.apply(self, args)</span><br><span class="line">      timer = <span class="literal">null</span></span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span> (<span class="params">fn, interval</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer,</span><br><span class="line">    firstTime = <span class="literal">true</span> <span class="comment">//是否首次调用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>,</span><br><span class="line">      self = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">if</span> (firstTime) &#123; <span class="comment">//如果是首次调用，不用延时</span></span><br><span class="line">      fn.apply(self, args)</span><br><span class="line">      <span class="keyword">return</span> firstTime = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">      fn.apply(self, args)</span><br><span class="line">      timer = <span class="literal">null</span></span><br><span class="line">    &#125;, interval)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onresize = throttle(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">document</span>.body.clientWidth)</span><br><span class="line">&#125;, <span class="number">250</span>)</span><br></pre></td></tr></table></figure>
<h4 id="7-_惰性载入函数">7. 惰性载入函数</h4><p>由于浏览器之间的差异，在开发前端的时候，一些特性嗅探操作总是不可避免的，比如一个比较通用的添加事件的函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addListener = <span class="function"><span class="keyword">function</span> (<span class="params">el, type, handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">    el.addEventListener(type, handler, <span class="literal">false</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    el.attachEvent(type, handler)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码的缺点是每次调用addListener都用执行里面的if分支判断，这种情况是完全可以避免的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addListener = <span class="function"><span class="keyword">function</span> (<span class="params">el, type, handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">    addListener = <span class="function"><span class="keyword">function</span> (<span class="params">el, type, handler</span>) </span>&#123;</span><br><span class="line">      el.addEventListener(type, handler, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    addListener = <span class="function"><span class="keyword">function</span> (<span class="params">el, type, handler</span>) </span>&#123;</span><br><span class="line">      el.attachEvent(type, handler)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  addListener(el, type, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码直接在函数内部重写了addListener函数，这样只有首次调用的时候需要做if判断，往后的调用都不需要再做判断。</p>
<h4 id="8-_html文本编码">8. html文本编码</h4><p>对于插入dom中的文本，我们需要对’&lt;&gt;&amp;”‘等特殊字符进行转义，通常可以像下面这样子做：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlEscape</span> (<span class="params">test</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> text.replace(<span class="regexp">/[&lt;&gt;&amp;"]/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">match</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (match) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'&lt;'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&amp;lt;'</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'&gt;'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&amp;gt;'</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'&amp;'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&amp;amp;'</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">'"'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&amp;quot;'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其实在浏览器环境中，还可以写成下面那样：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">htmlEscape</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">document</span>.createElement(<span class="string">'p'</span>).appendChild(<span class="built_in">document</span>.createTextNode(text)).parentNode.innerHTML</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="9-_简单的类型判断">9. 简单的类型判断</h4><p>例如判断一个变量是否为数组？只是使用instanceof的话在多个iframe的页面，由于不同iframe全局执行环境不同，存在多个不同的Array构造函数，不一定可行；在es5中可以直接使用静态方法Array.isArray()，而比较通用的方法则如下所示：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(value) === <span class="string">'[object Array]'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然除了数组，JavaScript中的基本类型和其他内置对象也可以用这种方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNumber</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(value) === <span class="string">'[object Number]'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="10-_检测是否为本地代码">10. 检测是否为本地代码</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isNative</span> (<span class="params">constructor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="regexp">/native code/</span>.test(constructor.toString())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如检测当前作用域下的Promise构造器是否为浏览器自带的Promise实现。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isNative(<span class="built_in">Promise</span>)</span><br></pre></td></tr></table></figure></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>JavaScript中有很多值得学习和记住的小技巧和经典的代码片段，在这里做个小总结。<br>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="https://xujiongbo.github.io/blog/tags/JavaScript/"/>
    
      <category term="JavaScript" scheme="https://xujiongbo.github.io/blog/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript测试框架]]></title>
    <link href="https://xujiongbo.github.io/blog/post/javascript-test-framework/"/>
    <id>https://xujiongbo.github.io/blog/post/javascript-test-framework/</id>
    <published>2015-11-09T05:38:40.000Z</published>
    <updated>2016-11-23T01:24:32.000Z</updated>
    <content type="html"><![CDATA[<h4 id="1-应该选哪种测试框架?">1.应该选哪种测试框架?</h4><p>现在比较流行的JavaScript测试框架有<a href="https://github.com/mochajs/mocha" target="_blank" rel="external">Mocha</a>，<a href="https://github.com/jasmine/jasmine" target="_blank" rel="external">Jasmine</a>，<a href="https://github.com/avajs/ava" target="_blank" rel="external">AVA</a>，这几种框架从根本上来说没有好坏之分，只有适不适合，选用哪种测试框架要看个人情况以及具体项目的类型决定。<br><a id="more"></a></p>
<h5 id="1-数据对比">1.数据对比</h5><p>关于它们的一些数据对比可以看<a href="https://npmcompare.com/compare/ava,jasmine,mocha" target="_blank" rel="external">这里</a>，可以看到Mocha比另外两个早发布两年，也是其中最流行的，Jasmine次之(尽管现在Jasmine的star数好像比Mocha多一点)。</p>
<h5 id="2-语法">2.语法</h5><p>这三种框架从语法层面来说大同小异，尤其是Mocha和Jasmine都提供了describe和it两个全局函数。</p>
<h4 id="2-应该选哪种断言库?">2.应该选哪种断言库?</h4><p>除了Node.js内置的assert module之外，比较流行的断言库有<a href="https://github.com/chaijs/chai" target="_blank" rel="external">chai</a>，<a href="https://github.com/shouldjs/should.js" target="_blank" rel="external">should.js</a>等。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h4 id="1-应该选哪种测试框架?">1.应该选哪种测试框架?</h4><p>现在比较流行的JavaScript测试框架有<a href="https://github.com/mochajs/mocha">Mocha</a>，<a href="https://github.com/jasmine/jasmine">Jasmine</a>，<a href="https://github.com/avajs/ava">AVA</a>，这几种框架从根本上来说没有好坏之分，只有适不适合，选用哪种测试框架要看个人情况以及具体项目的类型决定。<br>]]>
    
    </summary>
    
      <category term="mocha" scheme="https://xujiongbo.github.io/blog/tags/mocha/"/>
    
      <category term="test framework" scheme="https://xujiongbo.github.io/blog/tags/test-framework/"/>
    
      <category term="JavaScript" scheme="https://xujiongbo.github.io/blog/categories/JavaScript/"/>
    
  </entry>
  
</feed>
