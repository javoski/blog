<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Xujiongbo]]></title>
  
  <link href="/blog/atom.xml" rel="self"/>
  <link href="https://xujiongbo.github.io/blog/"/>
  <updated>2016-08-10T13:44:24.000Z</updated>
  <id>https://xujiongbo.github.io/blog/</id>
  
  <author>
    <name><![CDATA[Xujiongbo]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[理解async/await]]></title>
    <link href="https://xujiongbo.github.io/blog/post/understanding-async-await/"/>
    <id>https://xujiongbo.github.io/blog/post/understanding-async-await/</id>
    <published>2016-06-30T04:48:54.000Z</published>
    <updated>2016-08-10T13:44:24.000Z</updated>
    <content type="html"><![CDATA[<p>async/await已经成为es7 stage-4的一部分。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>async/await已经成为es7 stage-4的一部分。</p>
]]>
    </summary>
    
      <category term="JavaScript" scheme="https://xujiongbo.github.io/blog/tags/JavaScript/"/>
    
      <category term="JavaScript" scheme="https://xujiongbo.github.io/blog/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript小贴士]]></title>
    <link href="https://xujiongbo.github.io/blog/post/javascript-tips/"/>
    <id>https://xujiongbo.github.io/blog/post/javascript-tips/</id>
    <published>2016-01-21T08:17:27.000Z</published>
    <updated>2016-09-18T04:02:12.000Z</updated>
    <content type="html"><![CDATA[<p>JavaScript中有很多值得学习和记住的小技巧和经典的代码片段，在这里做个小总结。<br><a id="more"></a></p>
<h4 id="1-_链式方法">1. 链式方法</h4><p>jQuery中 $dom.html().css().addClass() 这类的就叫链式方法，在对象方法中返回对象本身(this)就可以实现。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Chain</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.val = val</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.print = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.val)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.setVal = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.val = val</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> chain = <span class="keyword">new</span> Chain(<span class="string">'foo'</span>)</span><br><span class="line">chain.print().setVal(<span class="string">'bar'</span>).print()</span><br><span class="line"><span class="comment">//foo</span></span><br><span class="line"><span class="comment">//bar</span></span><br></pre></td></tr></table></figure></p>
<h4 id="2-_注意字符串连接">2. 注意字符串连接</h4><p>JavaScript中经常会有一些意想不到的类型转换，’+’是其中最常见的一种运算，它既可以做数字的加法，也可以做字符串连接，不注意使用可能会出现不想看到的结果。看下面的例子<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c1 = <span class="number">12</span></span><br><span class="line"><span class="keyword">let</span> c2 = <span class="number">34</span></span><br><span class="line"><span class="keyword">let</span> c3 = <span class="string">'56'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result1 = c1 + c2 + c3 <span class="comment">//'4656'</span></span><br><span class="line"><span class="keyword">let</span> result2 = <span class="string">''</span>.concat(c1, c2, c3) <span class="comment">//'123456'</span></span><br></pre></td></tr></table></figure></p>
<p>结果1中先做了加法，而非我们期望的字符串连接，使用第二种方法更安全一些。<br>如果用了ES6，使用template string显然更方便。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> c1 = <span class="number">12</span></span><br><span class="line"><span class="keyword">let</span> c2 = <span class="number">34</span></span><br><span class="line"><span class="keyword">let</span> c3 = <span class="string">'56'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> result = <span class="string">`<span class="subst">$&#123;c1&#125;</span><span class="subst">$&#123;c2&#125;</span><span class="subst">$&#123;c3&#125;</span>`</span> <span class="comment">//'123456'</span></span><br></pre></td></tr></table></figure></p>
<h4 id="3-_使用双波浪运算(~~)">3. 使用双波浪运算(~~)</h4><p>‘~~’表示执行两次’~’运算，对于正数，它相当于Math.floor()，对于负数则相当于Math.ceil()，只是性能更高，写起来也更快，不过要注意它只能用于32位及以内的数值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~<span class="number">12</span>       <span class="comment">//-13</span></span><br><span class="line">~~<span class="number">12.34</span>     <span class="comment">//12</span></span><br><span class="line">~~<span class="number">12.89</span>     <span class="comment">//12</span></span><br><span class="line">~~-<span class="number">12.88</span>    <span class="comment">//-13</span></span><br></pre></td></tr></table></figure></p>
<h4 id="4-_使用!!总是返回Boolean类型">4. 使用!!总是返回Boolean类型</h4><p>‘!!’表示执行两次非运算，经过类型转换之后总是会返回布尔值，这在有些场景下会很有用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isLogin</span> (<span class="params">req</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !!req.session.user</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="5-_函数节流">5. 函数节流</h4><p>有时候我们需要防止某个函数执行过于频繁，以提高性能，比如window.onresize的callback等。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span> (<span class="params">fn, interval</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> timer,</span><br><span class="line">    firstTime = <span class="literal">true</span> <span class="comment">//是否首次调用</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">arguments</span>,</span><br><span class="line">      self = <span class="keyword">this</span></span><br><span class="line">    <span class="keyword">if</span> (firstTime) &#123; <span class="comment">//如果是首次调用，不用延时</span></span><br><span class="line">      fn.apply(self, args)</span><br><span class="line">      <span class="keyword">return</span> firstTime = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (timer) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      clearTimeout(timer)</span><br><span class="line">      fn.apply(self, args)</span><br><span class="line">      timer = <span class="literal">null</span></span><br><span class="line">    &#125;, interval)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onresize = throttle(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">document</span>.body.clientWidth)</span><br><span class="line">&#125;, <span class="number">250</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="6-_惰性载入函数">6. 惰性载入函数</h4><p>由于浏览器之间的差异，在开发前端的时候，一些特性嗅探操作总是不可避免的，比如一个比较通用的添加事件的函数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addListener = <span class="function"><span class="keyword">function</span> (<span class="params">el, type, handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">    el.addEventListener(type, handler, <span class="literal">false</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    el.attachEvent(type, handler)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码的缺点是每次调用addListener都用执行里面的if分支判断，这种情况是完全可以避免的<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> addListener = <span class="function"><span class="keyword">function</span> (<span class="params">el, type, handler</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.addEventListener) &#123;</span><br><span class="line">    addListener = <span class="function"><span class="keyword">function</span> (<span class="params">el, type, handler</span>) </span>&#123;</span><br><span class="line">      el.addEventListener(type, handler, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    addListener = <span class="function"><span class="keyword">function</span> (<span class="params">el, type, handler</span>) </span>&#123;</span><br><span class="line">      el.attachEvent(type, handler)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  addListener(el, type, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码直接在函数内部重写了addListener函数，这样只有首次调用的时候需要做if判断，往后的调用都不需要再做判断。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>JavaScript中有很多值得学习和记住的小技巧和经典的代码片段，在这里做个小总结。<br>]]>
    
    </summary>
    
      <category term="JavaScript" scheme="https://xujiongbo.github.io/blog/tags/JavaScript/"/>
    
      <category term="JavaScript" scheme="https://xujiongbo.github.io/blog/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript测试框架]]></title>
    <link href="https://xujiongbo.github.io/blog/post/mocha-should.js/"/>
    <id>https://xujiongbo.github.io/blog/post/mocha-should.js/</id>
    <published>2015-11-09T05:38:40.000Z</published>
    <updated>2016-08-10T14:00:48.000Z</updated>
    <content type="html"><![CDATA[<p>简要介绍使用 mocha + should.js 来编写简单的测试单元和测试模块。<br><a id="more"></a></p>
<h4 id="1-_断言组件assert">1. 断言组件assert</h4><p>在介绍mocha之前，先来了解一下assert。<br><a href="http://nodejs.cn/api/assert.html" target="_blank" rel="external">assert</a> 是node.js内置的一个module，用法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> assert = <span class="built_in">require</span>(<span class="string">'assert'</span>)</span><br></pre></td></tr></table></figure></p>
<p>它拥有一下几个主要方法：</p>
<pre><code>- <span class="keyword">assert</span>.[not]equal(<span class="annotation">actual</span>, expected[,message])，相当于 ==
- <span class="keyword">assert</span>(<span class="keyword">value</span>[,message]) 或者 <span class="keyword">assert</span>.ok(<span class="keyword">value</span>[,message])，相当于<span class="keyword">assert</span>.equal(true, !!<span class="keyword">value</span>[,message])
- <span class="keyword">assert</span>.[not]deepEqual(<span class="annotation">actual</span>, expected[, message])，在基本类型上来说与equal一致，只对可枚举类型有意义
- <span class="keyword">assert</span>.[not]StrictEqual(<span class="annotation">actual</span>, expected[, message])，相当于 ===
- <span class="keyword">assert</span>.[not]DeepStrictEqual(<span class="annotation">actual</span>, expected[, message])
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<p>简要介绍使用 mocha + should.js 来编写简单的测试单元和测试模块。<br>]]>
    
    </summary>
    
      <category term="mocha" scheme="https://xujiongbo.github.io/blog/tags/mocha/"/>
    
      <category term="should.js" scheme="https://xujiongbo.github.io/blog/tags/should-js/"/>
    
      <category term="JavaScript" scheme="https://xujiongbo.github.io/blog/categories/JavaScript/"/>
    
  </entry>
  
</feed>
